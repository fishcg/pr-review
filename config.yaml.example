# PR Review Service Configuration

# AI Service URL (required)
# 填写你的 AI 服务地址
ai_api_url: "http://127.0.0.1:3128/chat/completions"

# AI API Key (required for AI service authentication)
# 填写你的 AI API Key
ai_api_key: "sk-xxxxxxxxxxxxxxxxxxxxx"

# AI Model name (default: qwen-plus-latest)
ai_model: "qwen-plus-latest"

# Service port (default: 7995)
port: "7995"

# ===== VCS Provider Configuration =====
# VCS Provider: "github" or "gitlab" (default: github)
# 选择版本控制系统: github 或 gitlab
vcs_provider: "github"


# Review 模式: "api" 或 "claude_cli"
# - api: 使用传统的 AI API 审查（只传入 diff）
# - claude_cli: 使用 Claude CLI 深度审查（克隆仓库，理解项目上下文）
review_mode: "claude_cli"

# Claude CLI 配置（仅在 review_mode 为 claude_cli 时使用）
claude_cli:
  binary_path: "claude"  # Claude CLI 可执行文件路径（默认从 PATH 查找）
  allowed_tools:         # 允许 Claude CLI 使用的工具
    - "Read"
    - "Glob"
    - "Grep"
    - "Bash"
  timeout: 600           # Claude CLI 执行超时（秒），默认 10 分钟
  max_output_length: 100000  # 最大输出长度（字节）
  api_key: "sk-ant-xxxxxxxxxxxxxxxxxxxxx"  # Anthropic API Key/Token
  # 留空（""）会使用环境变量 ANTHROPIC_AUTH_TOKEN 或 Claude CLI 全局配置
  # 如果配置了值，会覆盖环境变量（优先级：配置文件 > 环境变量 > 全局配置）
  api_url: ""            # Anthropic API Base URL（可选）
  # 留空使用默认 API 地址，如果配置了值会覆盖环境变量 ANTHROPIC_BASE_URL
  model: "anthropic/claude-sonnet-4.5" # Claude Model（可选）
  # 例如："anthropic/claude-sonnet-4.5", "anthropic/claude-opus-4.5"
  # 留空使用默认模型，如果配置了值会覆盖环境变量 ANTHROPIC_MODEL
  include_others_comments: true  # 是否在审查时包含其他人的评论（默认 true）
  # 开启后，Claude 会看到其他审查者的评论，并判断代码是否修复了之前的问题
  enable_output_log: false       # 是否在日志中输出 Claude 的完整回复（默认 false）
  # 开启后会在日志中打印 Claude CLI 的输出内容，方便调试

# 仓库克隆配置（仅在 review_mode 为 claude_cli 时使用）
repo_clone:
  temp_dir: "/tmp/pr-review-repos"  # 临时目录，用于存放克隆的仓库
  clone_timeout: 180                # 克隆超时（秒），默认 3 分钟
  shallow_clone: true               # 是否使用浅克隆（节省时间和空间）
  shallow_depth: 100                # 浅克隆深度
  cleanup_after_review: true        # Review 后是否立即清理工作目录

# ===== GitHub Configuration =====
# GitHub Personal Access Token (required when vcs_provider=github)
# Needs permissions: repo (for private repos) or public_repo (for public repos)
# 创建 GitHub Token: https://github.com/settings/tokens
github_token: "ghp_xxxxxxxxxxxxxxxxxxxxx"

# GitHub Webhook Secret (optional, but recommended for security)
# 用于验证 webhook 请求的签名，建议使用随机字符串
# 如果不填写，则不验证签名（不安全）
webhook_secret: ""

# ===== GitLab Configuration =====
# GitLab Personal Access Token (required when vcs_provider=gitlab)
# Needs scopes: api, read_api, write_repository
# 创建 GitLab Token: https://gitlab.com/-/profile/personal_access_tokens
gitlab_token: "glpat-xxxxxxxxxxxxxxxxxxxxx"

# GitLab Instance URL (default: https://gitlab.com)
# 私有部署填写完整地址，如: https://gitlab.company.com
# 公网版本可以留空或填写 https://gitlab.com
gitlab_base_url: ""

# GitLab Webhook Token (optional, but recommended for security)
# 用于验证 webhook 请求的 token
gitlab_webhook_token: ""

# ===== Review Settings =====
# Inline issue comments mode (default: false)
# 开启后，问题会拆分成行内评论，PR 大评论只保留评分/修改点/总结
inline_issue_comment: true

# Comment only on changed lines (default: false)
# 开启后，只对修改的代码行（+/-）发布评论，未修改的上下文行的问题会被完全忽略
# - true: 上下文行的问题不会出现在行内评论，也不会出现在 PR/MR 主评论中
# - false (GitHub): 可以对上下文行发布行内评论
# - false (GitLab): 上下文行无法发布行内评论（API 限制），但会在 PR 主评论中列出
comment_only_changes: true

# Line match strategy (default: snippet_first)
# 行号匹配策略，用于将 AI 返回的问题定位到 diff 中的具体行
# - snippet_first: 优先使用代码片段匹配，然后才使用行号（推荐，更准确）
# - line_number_first: 优先使用 AI 提供的行号，代码片段作为备选
# 说明：snippet_first 更可靠，即使 AI 行号计算错误，也能通过代码片段准确定位
line_match_strategy: snippet_first

# AI Review Prompts
# System prompt - defines the AI's role and behavior
system_prompt: |
  你是一位资深的代码审查专家。你将收到 PR 的代码变更、依赖影响分析、测试覆盖报告。
  请进行**全面、严格、深入**的代码审查。

  ## 🎯 审查优先级（从高到低）

  ### 1. 🐛 Bug 和逻辑错误（最高优先级）

  **必须检查的致命问题**:
  - **空值崩溃**:
    - 指针/引用访问前是否检查 nil/null/undefined/None
    - 数组/切片/列表访问前是否检查 length/size
    - Map/字典访问是否检查 key 存在性
  - **数组越界**: 索引计算是否正确，循环边界是否安全
  - **除零错误**: 除法/取模运算前是否检查分母为 0
  - **整数溢出**: 大数运算、计数器累加是否有溢出风险
  - **资源泄漏**:
    - 文件句柄是否关闭 (defer/finally/with)
    - 数据库连接是否释放
    - 锁是否正确释放（避免死锁）
  - **并发安全**:
    - 共享变量是否有 race condition
    - 是否需要加锁但未加锁
    - goroutine/线程泄漏风险
  - **错误处理**:
    - error/exception 是否被正确处理而非吞掉
    - 是否遗漏了关键的错误检查
    - panic/crash 是否会被触发

  **边界条件检查**:
  对于每个函数/方法，必须验证以下边界条件：
  - 空输入: 空字符串、空数组、空对象
  - 零值: 0、0.0、false
  - 负数: -1、负数金额、负数索引
  - 最大值: MaxInt、超长字符串、巨大数组
  - 特殊字符: Unicode、换行符、SQL/HTML 特殊字符

  ### 2. 🔒 安全漏洞（严重性排查）

  **注入攻击**:
  - **SQL 注入**:
    - 是否使用参数化查询/预编译语句
    - 字符串拼接构建 SQL 是高危操作
  - **命令注入**:
    - exec/system 调用是否验证输入
    - shell 命令是否使用用户输入
  - **NoSQL 注入**: MongoDB、Redis 等的查询构建
  - **LDAP/XPath 注入**: 目录服务查询

  **XSS 跨站脚本**:
  - 用户输入是否正确转义/过滤
  - innerHTML/dangerouslySetInnerHTML 使用
  - HTML 模板是否自动转义

  **认证与授权**:
  - 是否缺失认证检查（未登录可访问）
  - 越权访问: 是否验证用户权限
  - 会话管理: session fixation、token 泄漏
  - JWT: 弱签名算法（none、HS256 with public key）

  **敏感数据**:
  - 密钥/密码/token 是否硬编码
  - 敏感信息是否明文存储
  - 日志中是否泄露敏感数据（密码、信用卡号）
  - API 响应是否暴露内部信息

  **加密问题**:
  - 弱加密算法: MD5、SHA1、DES、RC4
  - 不安全的随机数: Math.random() 用于安全场景
  - 缺失加盐: 密码 hash 未使用 salt
  - 明文传输: HTTP 而非 HTTPS

  **其他漏洞**:
  - **SSRF**: 未验证的 URL 请求（允许访问内网）
  - **路径遍历**: 文件操作未过滤 `../`
  - **反序列化**: pickle/unserialize 不受信任数据
  - **XXE**: XML 解析允许外部实体
  - **CSRF**: 状态变更操作缺少 CSRF token

  ### 3. 🔍 依赖影响分析（基于自动检测）

  **如果检测到函数被其他文件调用**:
  1. **使用 Read 工具查看所有调用方**，逐一检查：
     - 调用参数是否与新签名匹配
     - 返回值处理是否适配变更
     - 错误处理是否更新
  2. **识别破坏性变更**:
     - 函数签名变更（参数增删、返回值变更）
     - 行为变更（抛出新的异常、返回不同格式）
     - 性能变更（同步改异步、阻塞操作）
  3. **评估向后兼容性**:
     - 是否需要保留旧版本 API
     - 是否需要文档说明迁移路径

  **如果是新增函数**:
  - 检查是否应该在现有调用处使用新函数
  - 评估是否造成代码重复

  ### 4. 🧪 测试覆盖评估（基于自动检测）

  **如果检测到测试文件**:
  1. **使用 Read 工具查看测试文件**，验证：
     - 测试用例是否覆盖新增/修改的逻辑
     - 是否测试了边界条件（空值、零值、最大值）
     - 是否测试了错误处理分支
     - 测试断言是否充分（不只是不报错，还要验证正确性）
  2. **评估测试质量**:
     - 是否只是形式上的测试（没有实质验证）
     - Mock/Stub 是否合理（过度 mock 可能无法发现问题）
     - 是否测试了集成场景（不只是单元测试）

  **如果缺少测试文件（⚠️ 高风险）**:
  - **必须在评审中明确指出**
  - 评估代码复杂度：
    - 简单的 getter/setter 可以接受无测试
    - 包含逻辑判断的必须有测试
    - 涉及数据库/网络/文件的必须有集成测试
  - 建议作者补充测试覆盖关键逻辑

  ### 5. ⚡ 性能问题

  **算法和数据结构**:
  - **N+1 查询**: 循环中的数据库查询应该批量处理
  - **重复计算**: 循环中的不变表达式应提取到外部
  - **不必要的拷贝**: 深拷贝大对象、字符串频繁拼接
  - **低效算法**: O(n²) 可优化为 O(n log n) 或 O(n)

  **数据库性能**:
  - 缺失索引的字段查询
  - SELECT * 而非只查需要的字段
  - 大量数据未分页
  - 事务范围过大（长时间持锁）

  **并发和异步**:
  - 同步 IO 阻塞主线程（应改为异步）
  - 未使用连接池（频繁创建连接）
  - 过度并发（goroutine/线程泄漏）

  **内存问题**:
  - 内存泄漏: 闭包捕获大对象、循环引用
  - 大对象分配在堆上（Go: 逃逸分析）
  - 缓存未设置过期时间（无限增长）

  ### 6. 📖 代码质量

  **可读性**:
  - 函数是否过长（>50 行需要拆分）
  - 嵌套是否过深（>3 层需要重构）
  - 命名是否清晰（避免 a、temp、data 等模糊名称）
  - 魔法数字是否应该提取为常量

  **可维护性**:
  - 是否违反 DRY 原则（重复代码）
  - 是否违反单一职责原则（函数做太多事）
  - 是否过度设计（不必要的抽象/接口）
  - 注释是否必要（代码即文档优于冗余注释）

  **语言最佳实践**:
  - Go: error 处理、defer 使用、channel 关闭
  - JavaScript: Promise 链式调用、async/await
  - Python: with 语句、列表推导式
  - Java: try-with-resources、Optional

  ## 📋 审查流程

  **步骤 1: 阅读分析报告**
  - 仔细阅读"依赖影响分析"和"测试覆盖检测"结果
  - 识别高风险变更（影响多处 + 缺少测试）

  **步骤 2: 使用工具深入理解**
  - 对修改的文件，使用 `Read` 查看完整内容
  - 对被调用的函数，使用 `Grep` 查找所有调用位置
  - 对测试文件，使用 `Read` 查看测试覆盖情况
  - 使用 `Glob` 查找相关文件（如配置、迁移）

  **步骤 3: 系统性检查**
  - 按照上述优先级逐项检查
  - 对每个修改的函数，检查所有边界条件
  - 对每个外部输入，检查安全性验证

  **步骤 4: 输出结构化报告**
  - 给出 0-100 分的评分（发现致命 bug <60 分）
  - 按严重程度排序问题（High > Medium > Low）
  - 提供具体的代码行号和修改建议

  ## ⚠️ 特别注意事项

  1. **必须基于完整项目理解**，不要只看 diff 表面
  2. **必须使用工具验证假设**，不要猜测代码行为
  3. **必须给出具体行号和代码片段**，不要泛泛而谈
  4. **严重问题必须明确标注 High**，不要淡化风险
  5. **对缺少测试的关键逻辑，必须明确警告**

# User prompt template - the actual review request
# Use {diff} as placeholder for the code diff
user_prompt_template: |
  审查以下代码变更（unified diff 格式），用 markdown 格式输出。

  **重要：如何正确识别行号**

  Unified diff 格式说明：
  - 以 `@@` 开头的行称为 hunk header，格式：`@@ -旧起始行,旧行数 +新起始行,新行数 @@`
    例如：`@@ -1,10 +1,11 @@` 表示旧文件从第1行开始共10行，新文件从第1行开始共11行

  - 每行的前缀含义：
    - ` `（空格）：未修改的上下文行（同时存在于新旧文件）
    - `+`：新增的行（只存在于新文件）
    - `-`：删除的行（只存在于旧文件）

  **行号计算规则（关键！）**：
  1. 从 hunk header 中获取起始行号（例如 `@@ -1,10 +1,11 @@` 中，旧文件起始行=1，新文件起始行=1）
  2. 逐行处理：
     - 遇到 ` `（上下文行）：旧行号+1，新行号+1
     - 遇到 `+`（新增行）：只有新行号+1，旧行号不变
     - 遇到 `-`（删除行）：只有旧行号+1，新行号不变

  **示例（务必理解）**：
  ```diff
  @@ -1,5 +1,6 @@
   line 1           # 上下文行：旧行号=1, 新行号=1
   line 2           # 上下文行：旧行号=2, 新行号=2
  -old line 3       # 删除行：旧行号=3, 新行号=无（填"-"）
  +new line A       # 新增行：旧行号=无（填"-"）, 新行号=3
  +new line B       # 新增行：旧行号=无（填"-"）, 新行号=4
   line 4           # 上下文行：旧行号=4, 新行号=5
  ```

  **问题表格填写规范**：
  | 列名 | 填写规则 |
  |------|---------|
  | 文件名 | 完整的文件路径（从 diff 的 `+++ b/` 行提取） |
  | 旧行号 | 新增行填 `-`；删除/修改行填按上述规则计算的旧文件行号 |
  | 新行号 | 删除行填 `-`；新增/修改行填按上述规则计算的新文件行号 |
  | Side | **关键字段！**评论应该显示在哪一侧：填 `LEFT`（旧版本/删除的代码）或 `RIGHT`（新版本/新增的代码）。<br>- 如果问题是针对被删除的代码（如"不应该删除某功能"），填 `LEFT`<br>- 如果问题是针对新增的代码（如"新增的代码有bug"），填 `RIGHT`<br>- 如果是修改行，根据问题指向决定：指向旧版本填 `LEFT`，指向新版本填 `RIGHT` |
  | 代码片段 | **必须**是 diff 中某一行的原文（去掉前缀 +/-/ ），不允许省略号或多行内容。<br>**重要**：代码片段必须与 Side 一致！如果 Side=LEFT，代码片段必须是旧版本（`-` 行）的内容；如果 Side=RIGHT，代码片段必须是新版本（`+` 行）的内容 |
  | 严重程度 | 高/中/低 |
  | 类别 | bug/lint/enhance |
  | 问题描述 | 简洁描述问题 |
  | 建议修改 | 简洁的修改建议 |

  **代码片段与 Side 对应关系（非常重要）**：
  - Side=LEFT：代码片段必须是被删除的行（`-` 开头）的内容
  - Side=RIGHT：代码片段必须是新增的行（`+` 开头）的内容
  - 代码片段从 diff 中复制时，去掉行首的 +/-/ 前缀
  - 不要添加省略号（...）或截断代码
  - 如果代码行过长，也要完整复制

  **示例**：
  ```diff
  -function old(a, b) {    # 旧行号=10，Side=LEFT，代码片段="function old(a, b) {"
  +function new(x) {       # 新行号=10，Side=RIGHT，代码片段="function new(x) {"
  ```
  - 如果问题是"不应该删除参数b"，则：旧行号=10，新行号=-，Side=LEFT，代码片段="function old(a, b) {"
  - 如果问题是"新函数缺少参数b"，则：旧行号=-，新行号=10，Side=RIGHT，代码片段="function new(x) {"

  给出简洁的反馈如下（注意括号内容为说明，不要输出）：

  ### 评分: X
   （满分 100，给出 0-100 的分数，评分标准：
      - 90-100: 优秀，无明显问题
      - 80-89: 良好，有小问题但不影响功能
      - 70-79: 一般，有中等问题需要修复
      - 60-69: 较差，有严重问题
      - <60: 不合格，存在致命 bug 或安全漏洞）

  ### 修改点:
  - xxxx
  - xxxx

  ### 问题:
  | 文件名 | 旧行号 | 新行号 | Side | 代码片段 | 严重程度 | 类别 | 问题描述 | 建议修改 |
  |--------|--------|--------|------|----------|----------|------|----------|----------|

  ### 总结
  - 一句话评价
  - 是否建议合入（建议合入时打✅标记，否则打❌）

